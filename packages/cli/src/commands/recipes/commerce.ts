import {bold} from 'chalk';
import {CliUx, Command} from '@oclif/core';
import {Trackable} from '../../lib/decorators/preconditions/trackable';
import SnapshotTemplate from '../../lib/recipes/commerce/snapshot-template.json';
import CatalogCreate from '../commerce/catalog/create';
import {
  HasNecessaryCoveoPrivileges,
  IsAuthenticated,
  Preconditions,
} from '../../lib/decorators/preconditions';
import {ensureDirSync, writeJsonSync} from 'fs-extra';
import SourceCatalogAdd from '../source/catalog/add';
import Push from '../org/resources/push';
import {join} from 'path';
import {Project} from '../../lib/project/project';
import {cwd} from 'process';
import {rmSync} from 'fs';
import {AuthenticatedClient} from '../../lib/platform/authenticatedClient';
import {FieldModel, IntervalUnit} from '@coveord/platform-client';
import {selectField} from '../../lib/catalog/questions';
import {getDocumentFieldsAndObjectTypeValues} from '../../lib/catalog/parse';
import {newTask, stopCurrentTask} from '../../lib/utils/spinner';
import {listAllFieldsFromOrg} from '../../lib/utils/field';

type CommandRunReturn<T extends typeof Command> = Promise<
  ReturnType<InstanceType<T>['run']>
>;

export default class CommerceRecipe extends Command {
  private static tempFolder = join(cwd(), '.coveo-recipe');
  public static description = `${bold.bgYellow(
    '(alpha)'
  )} Create a commerce catalog interactively along with necessary sources`;

  public static flags = {
    ...CatalogCreate.flags,
  };

  public static args = [...CatalogCreate.args];

  @Trackable()
  @Preconditions(
    IsAuthenticated(),
    HasNecessaryCoveoPrivileges()
    //   TODO:
  )
  public async run() {
    // FIXME: Should find a cleaner way to run processes and store variables at the beginning of the recipe so they can be used by multiple steps
    const {flags, args} = await this.parse(CommerceRecipe);
    this.ensureTempFolder();
    const fieldNames = await this.getFieldNames();
    const {sourceId, product} = await this.newStep(
      'Catalog creation',
      CatalogCreate,
      [
        args.name,
        '--json',
        '--sourceVisibility',
        flags.sourceVisibility,
        '--dataFiles',
        ...flags.dataFiles,
      ]
    );
    this.storeParametrizedSnapshotLocally(product.objectType, args.name); // TODO: Maybe have multiple snapshots. each one with a specific config (eg. with product grouping feature)
    await this.newStep('Organization setup', Push, [
      '--sync',
      '--skipPreview',
      '--projectPath',
      CommerceRecipe.tempFolder,
      '--wait',
      '600',
    ]);
    await this.additionalCommerceFeatures(fieldNames);
    await this.newStep('Indexation', SourceCatalogAdd, [
      sourceId,
      '--createMissingFields',
      '--fullUpload',
      '--skipFullUploadCheck',
      '--files',
      ...flags.dataFiles,
    ]);
  }

  @Trackable()
  public async catch(err?: Error & {exitCode?: number}) {
    // TODO: CDX-1008: temporary fix until we actually ensure that oclif prints all errors (not only instanceof Error objects)
    if (err && !(err instanceof Error)) {
      const logger = typeof err === 'string' ? CliUx.ux.error : console.error;
      logger('Recipe step failed');
      logger(err);
    }
    throw err;
  }

  public async finally(_?: Error) {
    try {
      this.cleanTempFolder();
      super.finally(_);
    } catch (error) {
      // noop
    }
  }

  private storeParametrizedSnapshotLocally(
    objectType: string,
    catalogId: string
  ) {
    const objectTypeReplacementRegex = new RegExp('{{objecttype}}', 'gm');
    const catalogIdReplacementRegex = new RegExp('{{catalogId}}', 'gm');
    const snapshot = JSON.stringify(SnapshotTemplate)
      .replace(objectTypeReplacementRegex, objectType)
      .replace(catalogIdReplacementRegex, catalogId);
    const snapshotPath = join(
      CommerceRecipe.tempFolder,
      Project.resourceFolderName,
      'ALL.json' // The name of the snapshot file does not matter
    );

    writeJsonSync(snapshotPath, JSON.parse(snapshot), {spaces: 2});
  }

  /**
   * TODO: SRC-5050
   * Creating ML model manually since not possible with snapshot
   * The DNE ML model configuration contains a parameter (documentGroupId) that is autogenerated by the platform and unique to the org.
   * Therefore, it is not possible to guess that value
   */
  private async createMlModel(fieldNames: string[]) {
    // ec_category
    const enableDNE = await CliUx.ux.confirm(
      'Create a Navigation Experience (DNE) Model (https://docs.coveo.com/en/3396)? (y/n)'
    );
    if (!enableDNE) {
      return;
    }
    const field = await selectField(
      'Select the facet on which autoselect should apply',
      fieldNames
    );

    const authenticatedClient = new AuthenticatedClient();
    const platformClient = await authenticatedClient.getClient();
    newTask('Creating DNE ML model');
    const {modelId} = await platformClient.ml.dneConfig.createWithQuery({
      modelDisplayName: 'DNE',
      documentExtractionQuery: `(@${field})`,
      fieldsToAutoSelect: [`${field}`],
      intervalUnit: IntervalUnit.WEEK,
      exportPeriod: 'P3M',
    });
    if (!modelId) {
      CliUx.ux.warn('No modelId found');
      return;
    }

    newTask('Associate DNE ML model to pipeline');
    const {organization} = authenticatedClient.cfg.get();
    const pipelines = await platformClient.pipeline.list({
      organizationId: organization,
    });
    const searchPipeline = pipelines.find((p) => p.name === 'Search');
    if (!searchPipeline?.id) {
      CliUx.ux.warn('No Search pipelines found');
      return;
    }

    await platformClient.pipeline.associations.associate(searchPipeline.id, {
      rankingModifier: 75,
      modelId: modelId,
      customQueryParameters: {
        facetOrdering: {isEnabled: true},
        facetValueOrdering: {isEnabled: true},
        facetAutoSelect: {isEnabled: false},
        rankingBoost: {isEnabled: true},
      },
    });
    stopCurrentTask();
  }

  private async getFieldNames(): Promise<string[]> {
    const {flags} = await this.parse(CommerceRecipe);
    const authenticatedClient = new AuthenticatedClient();
    const platformClient = await authenticatedClient.getClient();
    // FIXME: Find a way to prevent duplication of this part which is already being done in the catalog creation piece
    // This costs another document parse that can be prevented
    const {fields: detectedFieldsInData} =
      await getDocumentFieldsAndObjectTypeValues(
        platformClient,
        flags.dataFiles
      );
    const existingFieldsInOrg: FieldModel[] = await listAllFieldsFromOrg(
      platformClient
    );
    const pluckName = (fields: FieldModel[]) =>
      fields.map((f: FieldModel) => `${f.name}`);
    const fieldSet = new Set([
      ...pluckName(detectedFieldsInData),
      ...pluckName(existingFieldsInOrg),
    ]);
    return Array.from(fieldSet);
  }

  private async additionalCommerceFeatures(fieldNames: string[]) {
    this.logHeader('Additional Commerce Features');
    await this.setupProductGrouping(fieldNames);
    await this.createMlModel(fieldNames);
  }

  private async setupProductGrouping(fieldNames: string[]) {
    const enableProductGrouping = await CliUx.ux.confirm(
      'Enable Product Grouping (https://docs.coveo.com/en/l78i2152)? (y/n)'
    );
    if (!enableProductGrouping) {
      return;
    }
    await selectField('Select your grouping field', fieldNames);

    // TODO: Validate
    // * Must be of type String.
    // * Must be set as Facet. If not facet, update field

    // This is just all for show. It assumes the user answered yes.
    // TODO: handle case when user does not want to enable product grouping
  }

  private ensureTempFolder() {
    ensureDirSync(join(CommerceRecipe.tempFolder, Project.resourceFolderName));
  }

  private cleanTempFolder() {
    rmSync(CommerceRecipe.tempFolder, {force: true, recursive: true});
  }

  private logHeader(name: string) {
    CliUx.ux.log('');
    CliUx.ux.styledHeader(name);
  }

  private async newStep<T extends typeof Command>(
    name: string,
    command: T,
    argv?: string[]
  ): CommandRunReturn<T> {
    this.logHeader(name);
    return command.run(argv);
  }
}
