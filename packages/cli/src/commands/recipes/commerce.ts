import {bold} from 'chalk';
import {CliUx, Command} from '@oclif/core';
import {Trackable} from '../../lib/decorators/preconditions/trackable';
import SnapshotTemplate from '../../lib/recipes/commerce/snapshot-template.json';
import CatalogCreate from '../commerce/catalog/create';
import {
  HasNecessaryCoveoPrivileges,
  IsAuthenticated,
  Preconditions,
} from '../../lib/decorators/preconditions';
import {ensureDirSync, writeJsonSync} from 'fs-extra';
import SourceCatalogAdd from '../source/catalog/add';
import Push from '../org/resources/push';
import {join} from 'path';
import {Project} from '../../lib/project/project';
import {cwd} from 'process';
import {rmSync} from 'fs';
import {AuthenticatedClient} from '../../lib/platform/authenticatedClient';
import {FieldModel, FieldTypes, IntervalUnit} from '@coveord/platform-client';
import {selectFieldModel} from '../../lib/catalog/questions';
import {getDocumentFieldsAndObjectTypeValues} from '../../lib/catalog/parse';
import {newTask, stopCurrentTask} from '../../lib/utils/spinner';
import {listAllFieldsFromOrg} from '../../lib/utils/field';

type CommandRunReturn<T extends typeof Command> = Promise<
  ReturnType<InstanceType<T>['run']>
>;

export default class CommerceRecipe extends Command {
  private static tempFolder = join(cwd(), '.coveo-recipe');
  public static description = `${bold.bgYellow(
    '(alpha)'
  )} Create a commerce catalog interactively along with necessary sources`;

  public static flags = {
    ...CatalogCreate.flags,
  };

  public static args = [...CatalogCreate.args];

  @Trackable()
  @Preconditions(
    IsAuthenticated(),
    HasNecessaryCoveoPrivileges()
    //   TODO:
  )
  public async run() {
    // FIXME: Should find a cleaner way to run processes and store variables at the beginning of the recipe so they can be used by multiple steps
    const {flags, args} = await this.parse(CommerceRecipe);
    this.ensureTempFolder();
    const fields = await this.getFields();
    const {sourceId, product} = await this.newStep(
      'Catalog creation',
      CatalogCreate,
      [
        args.name,
        '--json',
        '--sourceVisibility',
        flags.sourceVisibility,
        '--dataFiles',
        ...flags.dataFiles,
      ]
    );
    const groupingIdField = await this.additionalCommerceFeatures(fields); // Should return a different snapshot template based on the user choices
    this.storeParametrizedSnapshotLocally(
      product.objectType,
      args.name,
      groupingIdField!
    );

    await this.newStep('Organization setup', Push, [
      '--sync',
      '--skipPreview',
      '--projectPath',
      CommerceRecipe.tempFolder,
      '--wait',
      '600',
    ]);
    await this.newStep('Indexation', SourceCatalogAdd, [
      sourceId,
      '--createMissingFields',
      '--fullUpload',
      '--skipFullUploadCheck',
      '--files',
      ...flags.dataFiles,
    ]);
  }

  @Trackable()
  public async catch(err?: Error & {exitCode?: number}) {
    // TODO: CDX-1008: temporary fix until we actually ensure that oclif prints all errors (not only instanceof Error objects)
    if (err && !(err instanceof Error)) {
      const logger = typeof err === 'string' ? CliUx.ux.error : console.error;
      logger('Recipe step failed');
      logger(err);
    }
    throw err;
  }

  public async finally(_?: Error) {
    try {
      this.cleanTempFolder();
      super.finally(_);
    } catch (error) {
      // noop
    }
  }

  private storeParametrizedSnapshotLocally(
    objectType: string,
    catalogId: string,
    groupingId: string
  ) {
    const objectTypeReplacementRegex = new RegExp('{{objecttype}}', 'gm');
    const catalogIdReplacementRegex = new RegExp('{{catalogId}}', 'gm');
    const groupingIdReplacementRegex = new RegExp('{{ec_item_group_id}}', 'gm');
    const snapshot = JSON.stringify(SnapshotTemplate)
      .replace(objectTypeReplacementRegex, objectType)
      .replace(catalogIdReplacementRegex, catalogId)
      .replace(groupingIdReplacementRegex, groupingId);
    const snapshotPath = join(
      CommerceRecipe.tempFolder,
      Project.resourceFolderName,
      'ALL.json' // The name of the snapshot file does not matter
    );

    writeJsonSync(snapshotPath, JSON.parse(snapshot), {spaces: 2});
  }

  /**
   * TODO: SRC-5050
   * Creating ML model manually since not possible with snapshot
   * The DNE ML model configuration contains a parameter (documentGroupId) that is autogenerated by the platform and unique to the org.
   * Therefore, it is not possible to guess that value
   */
  private async createMlModel(fields: FieldModel[]) {
    const enableDNE = await CliUx.ux.confirm(
      'Create a Navigation Experience (DNE) Model (https://docs.coveo.com/en/3396)? (y/n)'
    );
    if (!enableDNE) {
      return;
    }
    const {name} = await selectFieldModel(
      'Select the facet on which autoselect should apply',
      fields
    );

    const {organization} = this.configuration;
    const client = await this.client;

    newTask('Creating DNE ML model');
    const {modelId} = await client.ml.dneConfig.createWithQuery({
      modelDisplayName: 'DNE',
      documentExtractionQuery: `(@${name})`,
      fieldsToAutoSelect: [`${name}`],
      intervalUnit: IntervalUnit.WEEK,
      exportPeriod: 'P3M',
    });
    if (!modelId) {
      CliUx.ux.warn('No modelId found');
      return;
    }

    newTask('Associate DNE ML model to pipeline');

    const pipelines = await client.pipeline.list({
      organizationId: organization,
    });
    const searchPipeline = pipelines.find((p) => p.name === 'Search');
    if (!searchPipeline?.id) {
      CliUx.ux.warn('No Search pipelines found');
      return;
    }

    await client.pipeline.associations.associate(searchPipeline.id, {
      rankingModifier: 75,
      modelId: modelId,
      customQueryParameters: {
        facetOrdering: {isEnabled: true},
        facetValueOrdering: {isEnabled: true},
        facetAutoSelect: {isEnabled: false},
        rankingBoost: {isEnabled: true},
      },
    });
    stopCurrentTask();
  }

  private async getFields(): Promise<FieldModel[]> {
    const {flags} = await this.parse(CommerceRecipe);
    const client = await this.client;
    // FIXME: Find a way to prevent duplication of this part which is already being done in the catalog creation piece
    // This costs another document parse that can be prevented
    const {fields: detectedFieldsInData} =
      await getDocumentFieldsAndObjectTypeValues(client, flags.dataFiles);
    const existingFieldsInOrg: FieldModel[] = await listAllFieldsFromOrg(
      client
    );
    const fieldSet = new Set([...detectedFieldsInData, ...existingFieldsInOrg]);
    return Array.from(fieldSet);
  }

  private async additionalCommerceFeatures(fields: FieldModel[]) {
    this.logHeader('Additional Commerce Features');
    // FIXME: here we would need to make the snapshot paratrizable depending on the user's choices
    const field = await this.setupProductGrouping(fields);
    await this.createMlModel(fields);
    return field;
  }

  private async setupProductGrouping(
    fields: FieldModel[]
  ): Promise<string | undefined> {
    const enableProductGrouping = await CliUx.ux.confirm(
      'Enable Product Grouping (https://docs.coveo.com/en/l78i2152)? (y/n)'
    );
    if (!enableProductGrouping) {
      return;
    }
    const fieldModel = await selectFieldModel(
      'Select your grouping field',
      fields
    );

    if (fieldModel.type !== FieldTypes.STRING) {
      throw 'TODO: handle case where field is not of string type';
    }

    if (fieldModel.name && fieldModel.facet === false) {
      // TODO: update the field to be facetable. Field can be created or not at this point
    }

    return fieldModel.name;
  }

  private ensureTempFolder() {
    ensureDirSync(join(CommerceRecipe.tempFolder, Project.resourceFolderName));
  }

  private cleanTempFolder() {
    rmSync(CommerceRecipe.tempFolder, {force: true, recursive: true});
  }

  private logHeader(name: string) {
    CliUx.ux.log('');
    CliUx.ux.styledHeader(name);
  }

  private async newStep<T extends typeof Command>(
    name: string,
    command: T,
    argv?: string[]
  ): CommandRunReturn<T> {
    this.logHeader(name);
    return command.run(argv);
  }

  private get configuration() {
    const authenticatedClient = new AuthenticatedClient();
    return authenticatedClient.cfg.get();
  }

  private get client() {
    const authenticatedClient = new AuthenticatedClient();
    return authenticatedClient.getClient();
  }
}
